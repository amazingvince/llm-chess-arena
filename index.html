<!DOCTYPE html>
<html>
<head>
    <title>LLM Chess Arena</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/chessboard-js/1.0.0/chessboard-1.0.0.min.css">
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f8f9fa;
        }
        .game-container {
            display: grid;
            grid-template-columns: 250px 1fr 400px;
            gap: 20px;
        }
        .controls-panel {
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .board-container {
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .log-panel {
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .game-controls button {
            width: 100%;
            padding: 10px;
            margin: 5px 0;
            background: #007bff;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }
        .game-controls button:disabled {
            background: #ccc;
        }
        .settings-section {
            margin-top: 20px;
            padding: 10px;
            background: #f8f9fa;
            border-radius: 4px;
        }
        .input-group {
            margin: 10px 0;
        }
        .input-group label {
            display: block;
            margin-bottom: 5px;
        }
        .input-group input,
        .input-group select {
            width: 100%;
            padding: 8px;
            border: 1px solid #ced4da;
            border-radius: 4px;
        }
        .status-bar {
            margin-top: 10px;
            padding: 10px;
            background: #e9ecef;
            border-radius: 4px;
            display: flex;
            justify-content: space-between;
        }
        .reasoning-log {
            height: 400px;
            overflow-y: auto;
            padding: 10px;
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 4px;
            margin-top: 10px;
        }
        .move-entry {
            margin: 10px 0;
            padding: 10px;
            background: white;
            border-radius: 4px;
            box-shadow: 0 1px 2px rgba(0,0,0,0.1);
        }
        .move-entry.white {
            border-left: 4px solid #007bff;
        }
        .move-entry.black {
            border-left: 4px solid #28a745;
        }
        .move-entry.error {
            border-left: 4px solid #dc3545;
        }
        .move-entry.debug {
            border-left: 4px solid #ffc107;
            font-family: monospace;
            font-size: 0.9em;
        }
        .auto-play-controls {
            margin-top: 10px;
            padding: 10px;
            background: #f8f9fa;
            border-radius: 4px;
        }
        .debug-panel {
            margin-top: 10px;
            padding: 10px;
            background: #f8f9fa;
            border-radius: 4px;
        }
    </style>
</head>
<body>
    <h1>LLM Chess Arena</h1>
    
    <div class="game-container">
        <div class="controls-panel">
            <div class="game-controls">
                <button id="startBtn">Start New Game</button>
                <button id="stepBtn" disabled>Make Move</button>
                <button id="copyPgn">Copy PGN</button>
            </div>

            <!-- White Player Settings -->
            <div class="settings-section">
                <h3>White Player</h3>
                <div class="input-group">
                    <label>API Key:</label>
                    <input type="password" id="apiKey1" placeholder="Groq API Key">
                </div>
                <div class="input-group">
                    <label>Model:</label>
                    <select id="model1">
                        <option value="llama-3.3-70b-versatile">llama-3.3-70b-versatile</option>
                        <option value="llama-3.3-70b-specdec">llama-3.3-70b-specdec</option>
                    </select>
                </div>
                <div class="input-group">
                    <label>Temperature (0.1-1.0):</label>
                    <input type="range" id="temp1" min="0.1" max="1.0" step="0.1" value="0.7">
                    <span id="temp1Value">0.7</span>
                </div>
            </div>

            <!-- Black Player Settings -->
            <div class="settings-section">
                <h3>Black Player</h3>
                <div class="input-group">
                    <label>API Key:</label>
                    <input type="password" id="apiKey2" placeholder="Groq API Key">
                </div>
                <div class="input-group">
                    <label>Model:</label>
                    <select id="model2">
                        <option value="llama-3.3-70b-versatile">llama-3.3-70b-versatile</option>
                        <option value="llama-3.3-70b-specdec">llama-3.3-70b-specdec</option>
                    </select>
                </div>
                <div class="input-group">
                    <label>Temperature (0.1-1.0):</label>
                    <input type="range" id="temp2" min="0.1" max="1.0" step="0.1" value="0.7">
                    <span id="temp2Value">0.7</span>
                </div>
            </div>

            <div class="auto-play-controls">
                <div class="input-group">
                    <label>
                        <input type="checkbox" id="autoPlay"> Auto Play
                    </label>
                </div>
                <div class="input-group">
                    <label>Move Delay (ms):</label>
                    <input type="number" id="moveDelay" value="2000" min="500">
                </div>
                <div class="input-group">
                    <label>Max Retries:</label>
                    <input type="number" id="maxRetries" value="3" min="1" max="5">
                </div>
            </div>

            <div class="debug-panel">
                <div class="input-group">
                    <label>
                        <input type="checkbox" id="debugMode"> Debug Mode
                    </label>
                </div>
            </div>
        </div>

        <div class="board-container">
            <div id="board"></div>
            <div class="status-bar">
                <span id="turnIndicator">Turn: White</span>
                <span id="moveIndicator">Move: 1</span>
                <span id="gameStatus">Status: In Progress</span>
            </div>
        </div>

        <div class="log-panel">
            <h3>Move History & Analysis</h3>
            <div class="reasoning-log" id="reasoningLog"></div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.7.1/jquery.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/chessboard-js/1.0.0/chessboard-1.0.0.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/chess.js/0.10.3/chess.min.js"></script>
    <script>
        // Enhanced system prompt with more explicit instructions and examples
        const SYSTEM_PROMPT = `You are playing a game of chess. You must analyze the position and choose a valid move from the legal moves available.

CRITICAL REQUIREMENTS:
1. You MUST use Standard Algebraic Notation (SAN)
2. You MUST choose from the provided list of legal moves
3. Your move MUST be exactly as shown in the legal moves list
4. DO NOT modify or reformat the move notation

Example valid responses:
- For pawn moves: "e4", "d5", "exd5"
- For piece moves: "Nf3", "Bc4", "Qd4"
- For castling: "O-O" (kingside), "O-O-O" (queenside)
- For captures: "Bxe4", "Nxc6", "exd5"
- For checks: "Qd7+", "Nf7+"
- For checkmate: "Qh7#"

Common mistakes to AVOID:
- DO NOT use coordinates format (e2e4)
- DO NOT add unnecessary characters (P-e4, PxP)
- DO NOT modify the notation (E4, N-f3)
- DO NOT add unnecessary details (pawn to e4)

Previous game moves and current position will be provided.
Respond with a JSON object containing your move and reasoning:
{
    "move": "<your chosen move in EXACT SAN format>",
    "reasoning": "<your analysis and explanation>"
}`;

        class ChessGame {
            constructor() {
                this.game = new Chess();
                this.board = null;
                this.currentPlayer = 'white';
                this.moveCount = 1;
                this.autoPlayInterval = null;
                this.isProcessingMove = false;
                this.debugMode = false;
                this.retryCount = 0;

                this.initializeBoard();
                this.initializeControls();
                this.loadSettings();
            }

            initializeBoard() {
                this.board = Chessboard('board', {
                    position: 'start',
                    showNotation: true,
                    pieceTheme: 'https://chessboardjs.com/img/chesspieces/wikipedia/{piece}.png'
                });
                $(window).resize(() => this.board.resize());
            }

            initializeControls() {
                document.getElementById('startBtn').addEventListener('click', () => this.startNewGame());
                document.getElementById('stepBtn').addEventListener('click', () => this.makeMove());
                document.getElementById('copyPgn').addEventListener('click', () => this.copyPgnToClipboard());
                document.getElementById('autoPlay').addEventListener('change', (e) => this.toggleAutoPlay(e.target.checked));
                document.getElementById('debugMode').addEventListener('change', (e) => {
                    this.debugMode = e.target.checked;
                    this.logDebug('Debug mode ' + (this.debugMode ? 'enabled' : 'disabled'));
                });
                
                // Temperature display updates
                ['temp1', 'temp2'].forEach(id => {
                    document.getElementById(id).addEventListener('input', (e) => {
                        document.getElementById(id + 'Value').textContent = e.target.value;
                    });
                });

                // Save settings on change
                ['apiKey1', 'model1', 'temp1', 'apiKey2', 'model2', 'temp2'].forEach(id => {
                    document.getElementById(id).addEventListener('change', () => this.saveSettings());
                });
            }

            loadSettings() {
                const settings = JSON.parse(localStorage.getItem('chessSettings') || '{}');
                ['model1', 'temp1', 'model2', 'temp2'].forEach(key => {
                    const element = document.getElementById(key);
                    if (settings[key]) {
                        element.value = settings[key];
                        if (key.startsWith('temp')) {
                            document.getElementById(key + 'Value').textContent = settings[key];
                        }
                    }
                });
            }

            saveSettings() {
                const settings = {
                    model1: document.getElementById('model1').value,
                    temp1: document.getElementById('temp1').value,
                    model2: document.getElementById('model2').value,
                    temp2: document.getElementById('temp2').value
                };
                localStorage.setItem('chessSettings', JSON.stringify(settings));
            }

            sleep(ms) {
                return new Promise(resolve => setTimeout(resolve, ms));
            }

            async makeGroqApiCall(fen, model, apiKey, temperature, legalMoves, retryCount = 0) {
                const maxRetries = parseInt(document.getElementById('maxRetries').value);
                const gameHistory = this.game.history().join(' ');
                
                const userPrompt = `Current position (FEN): ${fen}
Game history: ${gameHistory || 'Opening position'}
Legal moves: ${legalMoves.join(', ')}

Choose a legal move from the provided list.
Your move MUST match exactly one of the legal moves shown above.
Respond with a JSON containing your chosen move and reasoning.`;

                try {
                    this.logDebug(`Making API call (attempt ${retryCount + 1}/${maxRetries + 1}):
Model: ${model}
Temperature: ${temperature}
Legal moves: ${legalMoves.join(', ')}
FEN: ${fen}`);

                    const startTime = Date.now();
                    const response = await fetch('https://api.groq.com/openai/v1/chat/completions', {
                        method: 'POST',
                        headers: {
                            'Authorization': `Bearer ${apiKey}`,
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            messages: [
                                {
                                    role: "system",
                                    content: SYSTEM_PROMPT
                                },
                                {
                                    role: "user",
                                    content: userPrompt
                                }
                            ],
                            model: model,
                            temperature: parseFloat(temperature),
                            max_tokens: 8024,
                            response_format: { type: "json_object" }
                        })
                    });

                    const endTime = Date.now();
                    this.logDebug(`API response time: ${endTime - startTime}ms`);

                    if (!response.ok) {
                        throw new Error(`API Error: ${response.status} ${response.statusText}`);
                    }

                    const data = await response.json();
                    const moveData = JSON.parse(data.choices[0].message.content);

                    this.logDebug(`API Response:
Move: ${moveData.move}
Reasoning: ${moveData.reasoning}`);

                    // Validate move
                    if (!moveData?.move || !legalMoves.includes(moveData.move)) {
                        throw new Error(`Invalid move: ${moveData.move}. Must be one of: ${legalMoves.join(', ')}`);
                    }

                    return moveData;
                } catch (error) {
                    this.logDebug(`Error in API call: ${error.message}`);

                    if (retryCount < maxRetries) {
                        this.logDebug(`Retrying in ${(retryCount + 1) * 2} seconds...`);
                        await this.sleep((retryCount + 1) * 2000);
                        return this.makeGroqApiCall(fen, model, apiKey, temperature, legalMoves, retryCount + 1);
                    }

                    throw error;
                }
            }

            async makeMove() {
                if (this.isProcessingMove || this.game.game_over()) return false;
                this.isProcessingMove = true;
                document.getElementById('stepBtn').disabled = true;

                try {
                    const player = this.currentPlayer === 'white' ? 1 : 2;
                    const apiKey = document.getElementById(`apiKey${player}`).value;
                    const model = document.getElementById(`model${player}`).value;
                    const temperature = document.getElementById(`temp${player}`).value;
                    
                    if (!apiKey) {
                        throw new Error(`API key required for ${this.currentPlayer} player`);
                    }

                    const legalMoves = this.game.moves();
                    this.logDebug(`Available moves for ${this.currentPlayer}: ${legalMoves.join(', ')}`);

                    const moveData = await this.makeGroqApiCall(
                        this.game.fen(),
                        model,
                        apiKey,
                        temperature,
                        legalMoves
                    );

                    // Make the move
                    const move = this.game.move(moveData.move);
                    if (!move) {
                        throw new Error('Move validation failed');
                    }

                    this.board.position(this.game.fen());
                    this.logMove(moveData);

                    // Update game state
                    this.currentPlayer = this.currentPlayer === 'white' ? 'black' : 'white';
                    if (this.currentPlayer === 'white') this.moveCount++;
                    this.updateStatus();

                    if (this.game.game_over()) {
                        this.handleGameOver();
                        return false;
                    }

                    return true;
                } catch (error) {
                    this.logError(error);
                    return false;
                } finally {
                    this.isProcessingMove = false;
                    document.getElementById('stepBtn').disabled = false;
                }
            }

            toggleAutoPlay(enabled) {
                if (enabled && !this.game.game_over()) {
                    const delay = parseInt(document.getElementById('moveDelay').value);
                    this.autoPlayInterval = setInterval(async () => {
                        if (this.game.game_over() || !document.getElementById('autoPlay').checked) {
                            this.toggleAutoPlay(false);
                            document.getElementById('autoPlay').checked = false;
                            return;
                        }
                        await this.makeMove();
                    }, delay);
                } else if (this.autoPlayInterval) {
                    clearInterval(this.autoPlayInterval);
                    this.autoPlayInterval = null;
                }
            }

            startNewGame() {
                if (this.autoPlayInterval) {
                    this.toggleAutoPlay(false);
                }
                this.game = new Chess();
                this.board.position('start');
                this.currentPlayer = 'white';
                this.moveCount = 1;
                document.getElementById('reasoningLog').innerHTML = '';
                document.getElementById('stepBtn').disabled = false;
                document.getElementById('autoPlay').checked = false;
                this.isProcessingMove = false;
                this.logDebug('Starting new game');
                this.updateStatus();
            }

            handleGameOver() {
                this.toggleAutoPlay(false);
                document.getElementById('autoPlay').checked = false;
                document.getElementById('stepBtn').disabled = true;
                
                let result = '';
                if (this.game.in_checkmate()) {
                    result = `Checkmate! ${this.currentPlayer === 'white' ? 'Black' : 'White'} wins!`;
                } else if (this.game.in_draw()) {
                    result = "Game ended in a draw!";
                } else if (this.game.in_stalemate()) {
                    result = "Game ended in stalemate!";
                }
                
                this.logMessage(result);
                this.logDebug(`Game over: ${result}`);
                this.updateStatus();
            }

            updateStatus() {
                document.getElementById('turnIndicator').textContent = `Turn: ${this.currentPlayer.charAt(0).toUpperCase() + this.currentPlayer.slice(1)}`;
                document.getElementById('moveIndicator').textContent = `Move: ${this.moveCount}`;
                let status = 'In Progress';
                if (this.game.in_checkmate()) status = 'Checkmate';
                else if (this.game.in_check()) status = 'Check';
                else if (this.game.in_draw()) status = 'Draw';
                else if (this.game.in_stalemate()) status = 'Stalemate';
                document.getElementById('gameStatus').textContent = `Status: ${status}`;
            }

            logMove(moveData) {
                const reasoningLog = document.getElementById('reasoningLog');
                const entry = document.createElement('div');
                entry.className = `move-entry ${this.currentPlayer}`;
                entry.innerHTML = `
                    <strong>${this.currentPlayer.charAt(0).toUpperCase() + this.currentPlayer.slice(1)} Move ${this.moveCount}:</strong> ${moveData.move}<br>
                    <strong>Reasoning:</strong> ${moveData.reasoning}
                `;
                reasoningLog.insertBefore(entry, reasoningLog.firstChild);
            }

            logError(error) {
                const entry = document.createElement('div');
                entry.className = 'move-entry error';
                entry.innerHTML = `<strong>Error:</strong> ${error.message}`;
                document.getElementById('reasoningLog').insertBefore(entry, reasoningLog.firstChild);
            }

            logMessage(message) {
                const entry = document.createElement('div');
                entry.className = 'move-entry';
                entry.innerHTML = `<strong>Game:</strong> ${message}`;
                document.getElementById('reasoningLog').insertBefore(entry, reasoningLog.firstChild);
            }

            logDebug(message) {
                if (!this.debugMode) return;
                const entry = document.createElement('div');
                entry.className = 'move-entry debug';
                entry.innerHTML = `<strong>[DEBUG]:</strong> ${message}`;
                document.getElementById('reasoningLog').insertBefore(entry, reasoningLog.firstChild);
            }

            copyPgnToClipboard() {
                const pgn = this.game.pgn();
                navigator.clipboard.writeText(pgn)
                    .then(() => this.logMessage('PGN copied to clipboard'))
                    .catch(error => this.logError('Failed to copy PGN'));
            }
        }

        // Initialize the game when the page loads
        window.addEventListener('load', () => {
            window.game = new ChessGame();
        });
    </script>
</body>
</html>
